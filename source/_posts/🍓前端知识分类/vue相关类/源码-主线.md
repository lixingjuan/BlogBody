## new Vue

当我们执行new Vue的时候，实际上会调用`init.js`执行一系列的初始化
1. 合并options;
2. 初始化data、生命周期、methods、等等;

## $mount

```javascript
if(complier版本){

  /* doSomething to el */
  if(el挂载在 body or html){
    // 警告
  }

  /* 先，尝试获取templete(因为有多种定义templete) */
  /* 然后，获取到之后，使用compileToFunctions将其编译为render函数 */

  /* 最后，mount,挂载 */
  return mount.call(this, el, hydrating)
}
```


## render



`render`函数会遇到两种情况：
1. 模版类的化，调用 vm._c方法
2. 手写的`render`, 调用`vm.$createElement`

这两个方法的却比在于参数6，方法1是false, 方法2是true
而这两个方法，最终都会调用 `createElement`方法，返回一个`VNode`


<!-- 3. createElement:(在initRender阶段执行的) -->
<!-- 将我们的DOM编译为virtual -->
<!--  -->
<!-- ```js -->
<!-- <Templete> -->
  <!-- <div id='page-container'> -->
    <!-- {{ message }} -->
  <!-- </div> -->
<!-- <Templete/> -->
<!--  -->
<!-- <script> -->
<!-- export default { -->
  <!-- data(){ -->
    <!-- return { -->
      <!-- message: 'Hello World!' -->
    <!-- } -->
  <!-- } -->
<!-- } -->
<!-- </script> -->
<!-- ``` -->

<!-- 相当于 -->

<!-- ```js -->
<!-- /** -->
 <!-- * @des createElement -->
 <!-- * @param {Function} createElement  -->
 <!-- * @return:  -->
 <!-- */ -->
<!-- render(createElement){ -->
  <!-- return createElement('div', {    -->
    <!-- attr: { -->
      <!-- id: '#page-container' -->
    <!-- } -->
  <!-- }, this.message) -->
<!-- } -->
<!-- ``` -->

2. proxy: (在initRender阶段执行的)
对象访问做一个劫持，进行一些判断（如，变量render时未定义、模版否有多个根结点），然后发出一些警告

## virtual Node-VNode

virtual Node 的出现是因为操作DOM是比较耗费性能的，于是有了virtual Node 来描述DOM，VNode是virtual Node 在vue中的具体应用（借鉴自开源库snabbdom）；
VNode实际上是一个对象，去描述DOM结点。包含各种属性，如标签名、数据、子节点、键值等属性，还有一些用来拓展VNode的灵活性以及实现一些特殊的feature；
由于VNode只是映射到真实DOM的渲染，不需要包含操作DOM的方法，所以他是非常轻量和简单的；

virtual Node 除了他的数据结构和定义，映射到真实的DOM实际上要经历VNode的create、diff、patch等过程；

在vue中，create ,即createElement；

## createElement

vue.js使用`createElement`创建`VNode`，定义在 `src/core/create-element.js`中；
`createElement`实际上是对 `_createElement`做了一层封装，它允许传入的参数更加灵活，在处理完这些参数后，再去调用真正创建 `VNode`的函数 `_createElement`；

=> 见源码-createElement.md


大致了解了 `createElement` 创建 `VNode`的过程， 每个 `VNode`都有 `children`, `children` 每个元素也是一个 `VNode`，这样就形成了 **VNode Tree**, 他很好的描述了我们的 **DOM tree**

回到 mountComponent 函数的过程，我们已经知道 `vm._render` 是如何创建了一个 `VNode`，接下来就是要把这个`VNode`渲染为一个真实的DOM并渲染出来，这个过程是通过 vm._update完成的;


## _update

_update 方法的主要作用就是将 VNode 渲染为真实 DOM，定义在 `src/core/instance/lifecycle.js` 中；
_update 是vue 实例的一个私有方法，他被调用的时机有两个：
1. 一个是首次渲染；
2. 另一个是数据更新的时候；(响应式原理)

详见 => _update.md


## 组件化

vue 的另一个核心就是允许我们吧页面拆分为多个组件，每个组件依赖的css,jsvascript，模版，图片放在一起开发和维护；
组件是资源独立的，组件在系统内部可复用，组件和组件之前可以嵌套；

vue组件初始化的一个过程如下

```js
import Vue from 'vue'
import App from './App.vue'

var app = new Vue({
  el:'#app',
  // 这里的 h 是createElement 方法
  render: h => h(App)
})
```

这段代码是使用render函数去渲染的，不同的是，这次通过 createElement 传入的是一个组件而不是一个原生的标签，如下继续分析这一过程；

## createComponent


createComponent 是实现组件化的关键

在分析createElement的实现的时候，最终会调用 _createElement 方法，其中有一段逻辑是对参数tag的判断=> 
1. 如果一个普通的html标签, (如 div), 则会实例化一个普通的VNode节点;
2. 如果不是，则通过 createComponent 方法创建一个组件 VNode;

详见 => 源码-createComponent.md 

## patch

patch过程把 VNode 转换成真正的DOM节点。
通过之前的分析可知，再通过createComponet创建了组件Vnode, 接下来会走到vm._update, 执行vm.`__patch__` 去吧 VNode 转换成真正的DOM节点，但是针对一个普通的VNode节点，VNode创建过程有所不同。

patch的整体流程：
1. createComponent => 
2. 子组件初始化(init, createComponentInstanceForVnode, 整个子组件的init过程(合并options,lifecycle初始化等和vue一样的初始化过程)) => 
3. 子组件render(生成子组件的渲染vnode) => 
4. 子组件patch(渲染子组件的vnode，渲染的过程中如果还有子组件，就递归渲染) ;

详见 => 源码-patch.md

## 合并配置

对于options的合并有两个阶段（合并之后的结果保存在 vm.$options中）：
1. 外部调用场景下的合并配置是通过 `mergeOptions`, 并遵循一定的合并策略；
2. 组件合并是通过 `initInternalComponent`, 他的合并更快；
3. 框架和库的设计都是类似的，自身定义了很多默认配置，同时在初始化阶段传入自定义配置， 然后merge配置，来达到定制化不同需求的目的；


详见 => 源码-合并配置.md


## 生命周期

主要学习 Vue 生命周期中哥哥钩子函数的执行时机以及顺序
通过分析知道在 created 钩子函数中可以访问到数据，在 mounted 钩子函数中可以访问到 DOM，在 destroy 钩子函数中可以做一些定时器销毁工作，了解它们有利于我们在合适的生命周期去做不同的事情

详见 => 源码-生命周期.md


## 组件注册

了解全局注册和局部注册的区别

详见 => 源码-组件注册.md


## 异步组件

在平时的开发中，为了减少首屏代码体积，会把一些非首屏的组件设计成异步组件，按需加载，Vue 原生支持异步组件；

异步组件的实现有三种方式，它实现了 loading、resolve、reject、timeout 4 种状态
异步组件实现的本质是2次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点
当异步获取组件成功后，再通过 forceRender 强制重新渲染，这样就能正确渲染出我们异步加载的组件了


## 响应式原理

响应式对象是利用 Object.defineProperty() 给对象的属性添加 getter 和 setter
Vue会把 props 和 data 等变成响应式对象，在创建过程中若发现子属性也为对象，则递归把该对象变成响应式；
get: 依赖收集
set: 


## 依赖收集

依赖收集就是订阅数据变化的wather的收集
依赖收集的目的是为了当这些响应式数据发生变化的时候，触发他们的setter的时候，能知道应该通知哪些订阅者去做相应的逻辑处理；

## 派发更新