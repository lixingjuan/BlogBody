
# 🚌🚌🚌 知识点 -- 我的理解目录 🚌🚌🚌

## JS基础类


2. this? (详细见内页)
   1. this有四种绑定规则, 优先级依次
      1. new绑定：指向实例
      2. 显式绑定：call和apply显式绑定，bind硬绑定
      3. 默认绑定：调用位置是否有上下文对象（看是否被某个对象拥有或者包含），this即指向这个包含他的对象
      4. 隐式绑定：看是否被某个对象拥有或者包含



3. 继承的方法有哪些？优缺点是什么？（详见内页）
   1. 原型继承
      1. 缺点：无法实现多继承，所有实例都共享父类实例的方法
   2. 构造函数继承
   3. 组合继承
   4. ES6 extends

4. 前端跨域产生原因？常见解决方法？

5. 闭包相关 闭包原理？
   1. 闭包指的是有权访问另一个词法作用域的函数
   2. 常见的创建闭包的方式就是在一个函数内部创建另一个函数
   3. 当函数可以记住并访问其所在的函数作用域，使函数可以在他本身词法作用域以外执行，就产生了闭包

6. 闭包应用场景？
   1. 函数柯里化
   2. 变量缓存
   3. 实现类的继承
   4. 封装工厂函数
   5. 匿名自执行函数，因为执行之后外部无法访问其内部变量，执行完即销毁内存空间？

7.  闭包常见的坑？

8.  判断数据类型的方法有哪些？区别是什么？
    1. typeof
       1. 只能判断基础数据类型，除了Function,其他的使用能用new操作符创建的都是Object
       2. 变脸未声明返回'undefined'而不会抛出错误
       3. 有的地方说，正则表达式字面量，环境不同，结果不同，但是！！根据我的测试，结果均为object（FireFox，Node是Object, Chrome是Function）
    2. A instanceof B
       1. 用于判断A是否B的实例，即B的prototype属性，是否在A的原型链上
    3. Object.prototype.toString.call(A)
       1. 最完美的方式，除了有点长

9.  原型链的理解：
    1.  我理解，所有的对象都有一个 `prototype` 属性，指向他的原型，原型都有个costructor属性指向该对象;
    2.  我们可以通过new操作符创建该对象的实例，创建的实例拥有一个 `__proto__` 指针，指向其构造函数的原型对象;
    3.  实例可以继承其原型对象的所有可继承属性和方法;
    4.  原型链，当我们在一个对象上查找某属性的时候，若该对象有，就直接返回，若没有，则沿着原型链继续向上查到，查找到 OBject.prototype 即停止;
    5.  几乎所有的原型对象都是位于原型链顶端的 `Object` 的实例;


## 框架类
1. vue的data以函数返回？
   1. 避免变量共享

2. 是否遇到过Vue深层次对象双向绑定后，子组件未监听到更新的情况？怎么解决?
   1. 方法一：使用deep: true,但是有性能问题;
   2. 方法二：使用this.$set

3. vue的响应式怎么做到的？






